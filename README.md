(r)eal (s)imple (l)ogging (a)pi
================================

This Repository holds all concepts behind rsla and links to the real solutions.

TODO:
- Change name (API is not right. maybe engine?)
- find a logo
- Add a raml for the server api
- Add some puml graphics
  - CLI input parsing
  - example arch

- [Concepts](#concepts)
  - [A Log Entry](#a-log-entry)
  - [ID](#id)
  - [Source](#source)
  - [Level](#level)
  - [Message(140 chars)](#message140-chars)
  - [message_long](#message_long)
  - [TimeStamp](#timestamp)
- [Architecture](#architecture)
  - [Clients](#clients)
  - [Libraries](#libraries)
  - [Servers](#servers)
    - [Export Formats](#export-formats)
    - [Paths](#paths)
  - [Registries](#registries)
    - [Server](#server)
    - [Clients](#clients-1)
  - [Pipes](#pipes)
  - [Monitors](#monitors)
  - [Stats](#stats)
- [Links](#links)
  - [Servers](#servers-1)
  - [Clients](#clients-2)
  - [Libraries](#libraries-1)
  - [Registry-Server](#registry-server)
  - [Registry-Client](#registry-client)
  - [Pipes](#pipes-1)
  - [Stats](#stats-1)


# Concepts
Here are the concepts used by rsla

## A Log Entry
Consists of
* ID
* Source
* Level
* Message(140 chars)
* message_long
* TimeStamp

## ID
This is a unique ID. It is generated by the server using an uuid-generator compliant to [RFC 4122](https://tools.ietf.org/rfc/rfc4122.txt)

## Source
The Source that has sent the log entry

## Level
A Log-Level. May be any string you like.
We recommend:
* info
* warn
* error

## Message(140 chars)
A short version of the log message. You can send it to the server or leave the work of trimming the long message to the server.

## message_long
The Log Message in its full beauty. May Contain tags (#tag), other sources (@source) and links (http:// / https:// ...)

## TimeStamp
A [RFC 3339](https://tools.ietf.org/rfc/rfc3339.txt) date-time string (with or without UTC offset)

# Architecture
rsla consists of logging clients and servers to save logfiles.
Addtional components are registries (server and client), pipes and stats-clients

## Clients
All Clients must be able to:
* Write a Log Entry to any server
* Take any string and convert it to log-entry fields using regex and a config
* Read the full Get API
* CLI must take standard in or be able to use one argument, others are parameters
* CLI must be able to use a file-watcher
* GUIs must have all fields avaiable, may be hidden.
* Have a config with the following settings to be used as defaults:
	* Default Value for Level
	* Default Value Source
	* Default Value for a Server (IP:Port)
	* Default Message Parser ((.) == message)

## Libraries
Are Extensions / Classes / modules / plugins for other programs to use.
They:
* Write a Log Entry to any server
* Take any string and convert it to log-entry fields using regex and a config
* Read the full Get API
* Have a config with the following settings to be used as defaults:
	* Default Value for Level
	* Default Value Source
	* Default Value for a Server (IP:Port)
	* Default Message Parser ((.) == message)

## Servers
All Servers must be reachable via http and share in common:
* Export Formats
* HTTP-Paths

### Export Formats
You can get your data as:
* json
* xml
* csv
* txt

### Paths
* POST /log (body: source, level, message (optional), message_long, timestamp (optional))
* GET /log  - get all log entries
* GET /log/sources  - get all sources
* GET /log/levels  - get all Levels
* GET /log/tags  - get all Tags
* GET /log/:id  - get object with id
* GET /log/source/:source  - get all entries to source
* GET /log/level/:level - get all entries to level
* GET /log/tag/:tag - get all entries to tag
* GET /search?query (query: source, level, from, to, tag, string, ...)
* GET /log/timestamp/:from/[:to]  - get from, if no to then now
* GET /log/last  - get newest Entry
* GET /log/last/:number  - get newest entries, where number is the number of entries to get

## Registries
Can save logger api endpoints and display latest. And can search in the saves apis

### Server
A Registry must support the following Paths
* POST /server (body: api-endpoint, identifier) - Add a new Endpoint
* ...

### Clients
All clients must be able to consume and use the full regitry-server-api.

## Pipes
Consist of two parts:
1. Behaves like a Logger Server, but sends something (email, file, ftp) with the info
2. Watches for something and behaves like a client

## Monitors
Allow users to see changes in logs. This can be using sockets or creating an rss-feed.
Monitors are standalone and use existing API-Servers.

## Stats
Stats-Clients are special, as there are no limitations to them.
Just be sure not to overload the servers you perform stats against...

# Links
Here are the Links to all projects using these concepts. Entries that are not linked are planned, but not set up yet.
Feel Free to File a Pull-Request with more solutions or create one of the entries!

And please consider our naming convention:
`rsla-[type]-[language]`


## Servers
* rsla-server-php-mysql
* rsla-server-node.js-file

## Clients
* rsla-client-perl
* rsla-client-node.js-cli
* rsla-client-windows-console-application
* rsla-client-bash
* rsla-client-go

## Libraries
* rlsa-lib-nodejs
* rlsa-lib-php
* rsla-lib-csharp
* rsla-lib-go

## Registry-Server
* rsla-registry-server-php-mysql
* rsla-registry-server-node.js-file

## Registry-Client
* rsla-registry-client-perl
* rsla-registry-client-node.js-cli
* rsla-registry-client-windows-console-application
* rsla-registry-client-bash
* rsla-registry-client-go

## Pipes
* rsla-pipe-sending-mail-php
* rsla-pipe-receiving-mail-php
* rsla-pipe-sending-ftp-php
* rsla-pipe-receiving-ftp-php

## Monitors
* rsla-monitor-nodejs-socket-io
* rsla-monitor-php-rssfeed

## Stats
* rsla-stats-perl